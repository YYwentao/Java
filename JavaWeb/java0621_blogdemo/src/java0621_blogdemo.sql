/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50729
 Source Host           : localhost:3306
 Source Schema         : java0621_blogdemo

 Target Server Type    : MySQL
 Target Server Version : 50729
 File Encoding         : 65001

 Date: 02/07/2021 20:58:57
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `articleId` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `userId` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`articleId`) USING BTREE,
  INDEX `userId`(`userId`) USING BTREE,
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `user` (`userId`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, 'HTTP协议中GET和POST方法的区别总结', '1.\r\nGET 方法一般把用户自定义的数据放到 query string.\r\nPOST 方法一般把用户自定义的数据放到 body.\r\nGET 一般没有 body，POST一般有 body，但实际上，GET可以让它有 body，POST 也可以让它没 body.\r\n\r\n2.\r\nGET 方法一般设置成 “幂等”，POST方法一般不考虑“幂等”.\r\n幂等：某一个操作，操作一次和操作多次效果完全一样，符合这样的要求，就叫做“幂等”.\r\n读取数据一般是幂等的，修改数据一般就不是幂等的.\r\n\r\n3\r\nGET 请求一般可以被缓存，POST请求一般不可以被缓存.\r\n在访问同一个页面的时候，我们会发现第一次访问比后续访问速度会慢很多，这是因为浏览器访问页面是带有缓存的，第一次访问的时候会缓存一些页面中不太会改变的结果，二次访问就会从本地缓存这些内容，自然就加快了访问速度.\r\n\r\n4\r\nGET 请求可以被浏览器收藏夹保存起来，POST 请求一般不能被浏览器收藏夹保存(保存的话，body 部分就没了).\r\n\r\n结论：以上关于 POST 和 GET 的区别本质上都不大，POST 能完成的事 GET能完成，GET 能完成的事 POST 也能完成，所以没有没有本质区别。\r\n', 1);
INSERT INTO `article` VALUES (2, '抽象类和接口的区别', '抽象类\r\n定义：当一个方法被关键字abstract修饰被称为抽象方法，包含这个方法的类称为抽象类，用abstract关键字修饰\r\n\r\n抽象类和普通类的区别？\r\n\r\n抽象类不能被实例化，普通类可以实例化.\r\n抽象类和普通类都可以被继承，也可以发生向上转型、动态绑定.\r\n抽象类当中可以包含抽象方法和普通方法，如果这个抽象类被普通类继承，必须重写抽象方法，不然编译会报错。如果是被抽象类继承，可以不用重写.\r\n抽象类不能被final修饰，抽象方法不能是private\r\n接口\r\n定义：接口是抽象类的更进一步， 在抽象类中可以包含非抽象方法和字段，而接口中包含的方法都是抽象方法，字段只能包含静态常量（static final）.\r\n\r\n语法：使用关键字interface来修饰的\r\n\r\n特点：\r\n\r\n1.接口当中的方法默认是public abstract（都可以省略），不能有具体实现。但从jdk1.8开始，接口当中的方法可以有具体实现，但这个方法一定要用default修饰(当子类实现该接口之后，不需要重写该方法即可以调用该方法).\r\n2.接口中的属性默认是public static final（都可以省略），属性值不能被修改.\r\n3.接口出现是为了满足多继承的.\r\n\r\n抽象类和接口的区别?\r\n\r\n抽象类和接口都不能被实例化.\r\n接口中包含的方法都是抽象方法，包含的属性默认是静态常量.\r\n类和接口直接关系是implements，此时就要重写里面的所有的方法，因为都是抽象方法。类和类继承关系是用extends，接口和接口之间也是用extends.\r\n都可以发生向上转型，动态绑定.\r\n在Java中，类与类只能实现单继承，类与接口可以实现多个接口.\r\n核心区别: 抽象类中可以包含普通方法和普通字段，这样的普通方法和字段可以被子类直接使用(不必重写)，而接口中不能包含普通方法，子类必须重写所有的抽象方法。\r\n', 1);
INSERT INTO `article` VALUES (4, '面向对象语言的三大特性之封装、继承、多态', '一.面向对象\r\nC语言相信大家应该都不陌生，它是一门面向过程的语言，关注的是过程，通过分析求解问题的过程，再通过函数逐步调用，最后解决问题。\r\n\r\n而Java是基于面向对象的，关注的是对象，将一件事拆分为多个对象，通过对象之间的交互解决问题。\r\n\r\n1.1.怎么去形容面向对象呢？\r\n简单来说面向对象就是用代码(类)来描述客观世界的事物的一种方式， 一个类主要包含一个事物的属性和行为。面向对象其实就是一种思考问题的方式，是一种思想\r\n所以在用面向对象的思想去解决问题时就可以分为：找对象，建对象，用对象，并维护对象之间的关系。\r\n\r\n1.2.类和对象的概念\r\n类就是一类对象的统称。对象就是这一类具体化的一个实例。\r\n\r\n举个例子：盖房子的时候我们会有设计图纸，设计图纸就是一个类，而通过这个图纸我们就可以盖出房子，那么在这个例子当中，类就是那个图纸，而房子就是那个对象,所以房子就是一个实体。一个图纸可以实例化无数个对象(当然，正常情况下一个图纸建一个房子就好了，家里有矿的无所谓，你可以认为是在建别墅群)。\r\n\r\n总的来说：类相当于一个模板，对象是由模板产生的样本。一个类，可以产生无数的对象。\r\n\r\n声明一个类就是创建一个新的数据类型，而类在 Java 中属于引用类型， Java 使用关键字 class 来声明类。在一个类中有属性和方法，实例化通过new 关键字就可以创建一个对象，使用 . 来访问对象中的属性和方法。\r\n\r\n1.3.static关键字详解\r\nstatic关键字的作用\r\n\r\n1.修饰属性\r\n\r\n静态属性和类相关，和对象无关。就是说一个用static修饰的属性，它只是依赖于当前类，只能通过类名 . 属性访问可以改变属性值。通过当前类实例化后产生的对象无法访问，所以和对象无关。\r\n\r\nclass TestDemo{\r\n        public int a;\r\n        public static int count;\r\n}\r\npublic class Java20210531 {\r\n    public static void main(String[] args) {\r\n        TestDemo s1 = new TestDemo();\r\n        s1.a++;\r\n        TestDemo.count++;\r\n        System.out.println(s1.a);   //1\r\n        System.out.println(TestDemo.count); //1\r\n        System.out.println(\"============\");\r\n        TestDemo s2 = new TestDemo();\r\n        s2.a++;\r\n        TestDemo.count++;\r\n        System.out.println(s2.a);   //1\r\n        System.out.println(TestDemo.count); //2\r\n    }\r\n}\r\n\r\n2.修饰方法\r\n\r\n如果在任何方法上应用 static 关键字，此方法称为静态方法\r\n\r\n1.一样的，静态方法属于类，而不属于类的对象。\r\n2.可以直接调用静态方法，而无需创建类的实例(对象)。\r\n3.静态方法可以访问静态数据成员，并可以更改静态数据成员的值\r\n\r\nclass TestDemo{\r\n    public int a ;\r\n    public static int count;\r\n    public static void change() {\r\n    count = 20;\r\n    //a = 10; error 不可以访问非静态数据成员\r\n    }\r\n}\r\npublic class Java20210531 {\r\n    public static void main(String[] args) {\r\n    TestDemo.change();//无需创建实例对象 就可以调用\r\n    System.out.println(TestDemo.count);	//20\r\n    }\r\n}\r\n\r\n注意事项： 静态方法和对象无关, 而是和类相关. 因此这导致了两个情况(重点，选择题易错)：\r\n\r\n静态方法不能直接使用非静态数据成员或调用非静态方法(非静态数据成员和方法都是和实例相关的).\r\nthis和super两个关键字不能在静态上下文中使用(this 是当前对象的引用, super是当前对象对父类对象的引用, 也是和当前对象相关).\r\n二.封装\r\n2.1.什么是封装？\r\n软件开发本就是一个复杂的过程，如果代码程度复杂都过高，就不好维护，所以就引入一种管理代码的方式——封装。\r\n在写代码的时候会涉及到两种角色：类的实现者和类的调用者\r\n\r\n封装的本质就是让类的调用者不必要了解类的实现者是怎么实现类的，只需要知道如何使用就可以了。这样就降低了类使用者的学习和使用成本, 从而降低了复杂程度\r\n2.2.private实现封装\r\nJava 中对于字段和方法共有四种访问权限 。\r\n\r\n权限大小：private < default < protected < public\r\n\r\n当我们使用 private 来修饰字段的时候, 就无法直接使用这个字段了.\r\n此时如果需要获取或者修改这个 private 属性, 就需要使用 getter / setter 方法\r\n\r\nclass Person {\r\n	private String name;//实例成员变量\r\n	private int age;\r\n	public void setName(String name){\r\n	//name = name;//不能这样写\r\n	this.name = name;//this引用，表示调用该方法的对象\r\n	}\r\n	public String getName(){\r\n	return name;\r\n	}\r\n	public void show(){\r\n	System.out.println(\"name: \"+name+\" age: \"+age);\r\n	}\r\n}\r\npublic static void main(String[] args) {\r\n	Person person = new Person();\r\n	person.setName(\"tao\");\r\n	String name = person.getName();\r\n	System.out.println(name);\r\n	person.show();\r\n	// 运行结果\r\n	//tao\r\n	//name: tao age: 0\r\n}\r\n\r\n注意事项\r\n\r\ngetName 即为 getter 方法, 表示获取这个成员的值。setName 即为 setter 方法, 表示设置这个成员的值\r\n当set方法的形参名字和类中的成员属性的名字一样的时候，如果不使用this, 相当于自赋值。this 表示当前对象的引用\r\n三.继承\r\n在创建类的过程本身就是为了抽象现实中的一些事物(包含属性和方法)，有时候现实中的事物会有一些特定的关系，比如实现三个类，Animal类，cat类，dog类，我们会发现cat类和dog类都同属于Animal类，这种关系称之为继承 ，is a 表示关系\r\n\r\n继承：使用extends关键字 ，A extends B\r\nA：表示子类，派生类\r\nB：表示父类，超类，基类\r\n\r\n继承的作用主要是为了实现代码复用\r\n子类继承父类除构造方法外的所以属性和方法\r\n因为构造方法无法被继承，所以在子类中可以通过super关键字调用父类的构造器，要先帮助父类进行构造\r\n注意事项\r\n\r\n另外final关键字的功能是限制类被继承，如下：\r\n\r\nfinal关键字修饰一个变量或者字段的时候, 表示常量 (不能修改).\r\nfinal关键字修饰类, 此时表示被修饰的类就不能被继承\r\n面试问题：this和super的区别？\r\n\r\n1.this表示当前对象的引用 ————————super表示父类对象的引用\r\n2.this()：调用当前对象的构造方法 ———— super()：显示调用父类的构造方法(必须都放在第一行)\r\n3.this.data：调用当前对象的属性 —————super.data：调用父类对象的成员属性\r\n4.this.fun()：调用当前对象的方法 ————— super.fun() ：调用父类对象的方法\r\n\r\n四.多态\r\n在了解多态之前，我们需要先了解这几个概念：向上转型、方法重写、动态绑定。\r\n\r\n4.1.向上转型\r\n例如：\r\n\r\nAnimal cat= new Cat(\"小花\");\r\n1\r\n在上面的代码中，我知道Cat是子类，Animal是父类，而子类继承了父类，cat就是一个被实例化出来的对象，也可以称之为是父类(Animal)的引用。\r\n所以这行代码的意思：\r\n\r\n此时 cat 是一个父类 (Animal) 的引用, 指向一个子类 (Bird) 的实例(产生的对象). 这种写法称为 向上转型\r\n\r\nclass Animal {\r\n    protected String name;\r\n    public Animal(String name) {\r\n        this.name = name;\r\n    }\r\n    public void eat(String food) {\r\n        System.out.println(\"我是一只小动物\");\r\n        System.out.println(this.name + \"正在吃\" + food);\r\n    }\r\n}\r\n// Bird.java\r\n class Bird extends Animal {\r\n    public Bird(String name) {\r\n        super(name);\r\n    }\r\n    public void eat(String food) {\r\n        System.out.println(\"我是一只小鸟\");\r\n        System.out.println(this.name + \"正在吃\" + food);\r\n    }\r\n    public void fly1() {\r\n        System.out.println(\"飞\");\r\n    }\r\n}\r\n// Test.java\r\nclass Test {\r\n    public static void main(String[] args) {\r\n        Animal animal1 = new Animal(\"圆圆\");\r\n        animal1.eat(\"谷子\");\r\n        Animal animal2 = new Bird(\"扁扁\");\r\n        animal2.eat(\"谷子\");\r\n    }\r\n}\r\n\r\n\r\n向上转型在Java中非常的常见，但这里需要注意的通过实例化产生的对象只能访问父类的方法和属性(子类的方法可能大于父类的方法数量)\r\n\r\n4.2.方法重写\r\n子类实现父类的同名方法, 并且参数的类型和个数完全相同, 这种情况称为 覆写/重写/覆盖(Override)\r\n\r\n注意事项\r\n\r\n普通方法可以重写，static修饰的静态方法不能被重写，private权限的修饰方法不能被重写(private权限在当前类生效)\r\n子类如果重写父类的方法，那么子类访问修饰权限一定要大于等于父类的访问修饰的权限\r\n注意区分重写和重载的区别\r\n重载和重写的区别？(面试问题)\r\n\r\n重载要求方法名相同，参数类型和个数不同，返回值不做要求\r\n重写要求方法名相同，参数类型和个数必须相同，放回值也要相同(注：构成协变类型可以不相同)，final修饰的方法不能被重写\r\n\r\n协变返回类型一句话：子类覆盖父类方法，返回类型可以是，父类返回类型的子类。\r\n4.3.动态绑定\r\n当子类和父类中出现同名方法的时候, 再去调用会出现什么情况呢?\r\n其实这样就会打印出来子类的方法，这个时候就会很奇怪，不应该是调用父类，打印父类的方法嘛，在这个过程当中就发生动态绑定，又叫运行时绑定。\r\n\r\n概念1(太官方)：在 Java 中, 调用某个类的方法, 究竟执行了哪段代码 (是父类方法的代码还是子类方法的代码) , 要看究竟这个引用指向的是父类对象还是子类对象. 这个过程是程序运行时决定的, 因此称为 动态绑定.\r\n\r\n概念2(太口水话)：在Java中，如果满足父类和子类中都存在一个相同的方法，通过父类的引用在调用这个方法的时候，程序编译的是父类方法，在运行时绑定到了子类的方法，最后打印出来子类方法，这个过程称为 动态绑定\r\n\r\n注意：另外在构造方法中也可以发生动态绑定\r\n\r\n动态绑定发生的前提\r\n\r\n一定要发生向上转型\r\n父类和子类有同名的重写/覆盖/覆写方法\r\n理解多态\r\n有了对上面这些知识的了解后，我们就可以理解什么是多态，总的来说，多态是一种思想，是对同一个行为表现多种不同的表现形式…(这是啥？？？完全没懂，先上代码)\r\n\r\nclass Animal {\r\n    public void shout() {\r\n        //啥也不干\r\n    }\r\n}\r\nclass Cat extends Animal {\r\n    @Override\r\n    public void shout() {\r\n        System.out.println(\"喵喵喵\");\r\n    }\r\n}\r\nclass  Dog extends Animal {\r\n    @Override\r\n    public void shout() {\r\n        System.out.println(\"汪汪汪\");\r\n    }\r\n}\r\n/我是分割线//\r\npublic class Java20210531 {\r\n    public static void main(String[] args) {\r\n        Animal animal1 = new Cat();\r\n        Animal animal2 = new Dog();\r\n		animalShout(animal1);\r\n        animalShout(animal2);\r\n        //喵喵喵\r\n        //汪汪汪\r\n    }\r\n    public static void animalShout(Animal animal) {\r\n        animal.shout();\r\n    }\r\n}\r\n\r\n这个代码够简单了(捂脸)，很容易理解，分割线上面是类的实现者编写，下面是类的调用者编写，当类的调用者在编写 animalShout这个方法的时候, 参数类型为 Animal (父类), 此时在该方法内部并不知道, 也不关注当前的 animal 引用指向的是哪个类型(哪个子类)的实例. 此时 animal这个引用调用 shout()方法可能会有多种不同的表现(和 animal对应的实例相关), 这种行为就称为 多态.\r\n\r\n简单来说，多态就是在多个子类同时继承一个父类的情况下，并且每个子类都重写了父类的某个方法，再通过父类引用不同的子类对象，调用同一个方法时，就会根据你引用的子类对象动态绑定到子类的方法中。(表述如果有误，请指正)\r\n\r\n总结\r\n\r\n多态发生的前提，要先发生向上转型，方法的重写，动态绑定\r\nC++ 中的 “动态多态” 和 Java 的多态类似. 但是 C++ 还有一种 “静态多态”(模板), 就和继承体系没有关系了\r\nPython 中的多态体现的是 “鸭子类型”, 也和继承体系没有关系\r\nGo 语言中没有 “继承” 这样的概念, 同样也能表示多态\r\n无论是哪种编程语言, 多态的核心都是让调用者不必关注对象的具体类型. 这是降低用户使用成本的一种重要方式\r\n————————————————\r\n', 1);
INSERT INTO `article` VALUES (5, 'Java中数据类型和运算符的基本知识点', '1、数据类型\r\n1.1 整型变量\r\n	//基本语法格式\r\n	int 变量名 = 初始值;\r\n	int num = 10; // 定义一个整型变量\r\n	System.out.println(num) ;\r\n\r\n1.2 长整型变量\r\n	//基本语法格式\r\n	long 变量名 = 初始值;\r\n	long num = 10L; // 定义一个长整型变量, 初始值写作 10l 也可以	(小写的 L, 不是数字1).\r\n	System.out.println(num) ;\r\n\r\n1.3 双精度浮点型变量\r\n	//基本语法格式\r\n	double 变量名 = 初始值;\r\n	double num = 1.0;\r\n	System.out.println(num)\r\n\r\n1.4 单精度浮点型变量\r\n	//基本语法格式\r\n	float 变量名 = 初始值;\r\n	float num = 1.0f;   // 写作 1.0F 也可以\r\n	System.out.println(num);\r\n\r\n1.5 字符类型变量\r\n	//基本语法格式\r\n	char 变量名 = 初始值;\r\n	char ch = \'A\';\r\n\r\n1.6 字节类型变量\r\n	//基本语法格式\r\n	byte 变量名 = 初始值;\r\n	//代码示例:\r\n	byte value = 0;\r\n	System.out.println(value);\r\n\r\n1.7 短整型变量\r\n	//基本语法格式\r\n	short 变量名 = 初始值;\r\n	//代码示例:\r\n	short value = 0;\r\n	System.out.println(value);\r\n\r\n1.8 布尔类型变量\r\n	//基本语法格式:\r\n	boolean 变量名 = 初始值;\r\n	//代码示例:\r\n	boolean value = true;\r\n	System.out.println(value);\r\n\r\n总的来说\r\nJava中的变量类型主要分为四种八类\r\n分别是整形：byte、short、int、long(默认值为0)\r\n浮点型：double、float (默认值0)\r\n字符型：char (默认值\"\\u0000\")\r\n布尔型：boolean (默认值false)\r\n\r\n2、运算符的基本知识点\r\n2.1 算术运算符\r\na)基本四则运算符 + - * / %\r\n1\r\n比较简单，值得注意的是使用除法零不能作为除数，* 表示乘法、\r\n/ 表示取商 、% 表示取余\r\n\r\nb)增量赋值运算符 += -= *= /= %=\r\n\r\n	int a = 10;\r\n	a += 1; // 等价于 a = a + 1\r\n	System.out.println(a);\r\n\r\nc)自增/自减运算符 ++ --\r\n	int a = 10;\r\n	int b = ++a;\r\n	System.out.println(b);\r\n	int c = a++;\r\n	System.out.println(c);\r\n\r\n2.2 关系运算符\r\n关系运算符主要有六个:\r\n\r\n== != < > <= >=\r\n\r\nint a = 10;\r\nint b = 20;\r\nSystem.out.println(a == b);\r\nSystem.out.println(a != b);\r\nSystem.out.println(a < b);\r\nSystem.out.println(a > b);\r\nSystem.out.println(a <= b);\r\nSystem.out.println(a >= b);\r\n//注意: 关系运算符的表达式返回值都是 boolean 类型.\r\n\r\n2.3 逻辑运算符\r\n逻辑运算符主要有三个:\r\n \r\n && || !\r\n\r\n注意: 逻辑运算符的操作数(操作数往往是关系运算符的结果)和返回值都是 boolean .\r\n\r\n逻辑与 &&\r\n规则: 两个操作数都为 true, 结果为 true, 否则结果为 false.\r\n\r\n逻辑或 || 规则: 两个操作数都为 false, 结果为 false, 否则结果为 true\r\n逻辑非 !\r\n规则: 操作数为 true, 结果为 false; 操作数为 false, 结果为 true\r\n(这是个单目运算符, 只有一个操作数).\r\n\r\n2.4 位运算符(重点)\r\nJava 中对数据的操作的最小单位不是字节, 而是二进制位.\r\n位运算符主要有四个:\r\n\r\n& | ~ ^\r\n按位与 &: 如果两个二进制位都是 1, 则结果为 1, 否则结果为 0.\r\n按位或 |: 如果两个二进制位都是 0, 则结果为 0, 否则结果为 1.\r\n按位取反 ~: 如果该位为 0 则转为 1, 如果该位为 1 则转为 0\r\n按位异或 ^: 如果两个数字的二进制位相同, 则结果为 0, 相异则结果为 1.\r\n\r\n2.5 移位运算\r\n移位运算符有三个:\r\n\r\n<< >> >>>\r\n都是按照二进制位来运算.\r\n\r\n例如\r\n\r\n左移 <<: 最左侧位不要了, 最右侧补 0.\r\n1\r\nint a = 0x10;\r\nSystem.out.printf(\"%x\\n\", a << 1);\r\n// 运行结果(注意, 是按十六进制打印的)\r\n20\r\n\r\n2.6 条件运算符\r\n条件运算符只有一个:\r\n\r\n表达式1 ? 表达式2 : 表达式3\r\n\r\n当 表达式1 的值为 true 时, 整个表达式的值为 表达式2 的值; 当 表达式1 的值为 false 时, 整个表达式的值为 表达式3 的值.\r\n// 求两个整数的最大值\r\nint a = 10;\r\nint b = 20;\r\nint max = a > b ? a : b;\r\n————————————————\r\n', 1);
INSERT INTO `article` VALUES (6, 'Java实现单链表', '在数据结构中，链表的结构，就是一个个节点连接在一起，形成一个完整的链条，每个节点包含2部分，数据域，和一个指向下一个节点引用的指针next\r\n下面是代码：\r\n\r\npackage Linked.List;\r\n/**\r\n * ClassName: SingleLinkedList\r\n * Description: 1.无头单向非循环链表实现\r\n * @since JDK 1.8\r\n */\r\nclass Node {\r\n    //节点类型\r\n    public int data;//数据域\r\n    public Node next;//下一个节点引用\r\n\r\n    public Node(int data) {\r\n        this.data = data;\r\n        this.next = null;\r\n    }\r\n}\r\npublic class SingleLinkedList {\r\n\r\n    public Node head;   //保存单链表的头节点的引用\r\n    \r\n    //头插法\r\n    public void addFirst(int data) {\r\n        Node node = new Node(data);\r\n        node.next = this.head;\r\n        this.head = node;\r\n    }\r\n\r\n    //尾插法\r\n    public void addLast(int data) {\r\n        Node node = new Node(data);\r\n        if (this.head == null) {\r\n            this.head = node;\r\n        } else {\r\n            Node cur = this.head;\r\n            while (cur.next != null) {\r\n                cur = cur.next;\r\n            }\r\n            cur.next = node;\r\n        }\r\n    }\r\n\r\n    //任意位置插入一个数据节点为data号的下标\r\n    public void addIndex(int index, int data) {\r\n        Node node = new Node(data);\r\n        if (index == 0) {\r\n            addFirst(data);\r\n            return;\r\n        }\r\n        if (index == this.size()) {\r\n            addLast(data);\r\n            return;\r\n        }\r\n        //先找到 index位置的前一个节点的地址\r\n        Node cur = searchIndext(index);\r\n        //进行插入\r\n        node.next = cur.next;\r\n        cur.next = node;\r\n    }\r\n    private Node searchIndext(int index) {\r\n        //1.检查index的合法性\r\n        if (index < 0 || index > this.size()) {\r\n            throw new RuntimeException(\"index位置不合法\");\r\n        }\r\n        Node cur = this.head;\r\n        while (index - 1 != 0) {\r\n            cur = cur.next;\r\n            index--;\r\n        }\r\n        return cur;\r\n    }\r\n\r\n    //查找是否包含关键字key是否在单链表当中\r\n    public boolean contains(int key) {\r\n        Node cur = this.head;\r\n        while (cur != null) {\r\n            if (cur.data == key) {\r\n                return true;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //删除第一次出现关键字为key的节点\r\n    public void remove(int key) {\r\n        if (this.head == null) {\r\n            return;\r\n        }\r\n        //删除的是不是头节点\r\n        if (this.head.data == key) {\r\n            this.head = this.head.next;\r\n            return;\r\n        }\r\n        //调用找到删除节点的前驱\r\n        Node prev = searckkey(key);\r\n        if (prev == null) {\r\n            System.out.println(\"没有节点\");\r\n            return;\r\n        }\r\n        Node del = prev.next;\r\n        //开始删除\r\n        prev.next = del.next;\r\n    }\r\n    private Node searckkey(int key) {\r\n        Node prev = this.head;\r\n        while (prev.next != null) {\r\n            if (prev.next.data == key) {\r\n                //找到前驱\r\n                return prev;\r\n            } else {\r\n                prev = prev.next;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    //删除所有值为key的节点\r\n    public void removeAllKey(int key) {\r\n        if (this.head == null) {\r\n            return;\r\n        }\r\n        //prev前驱节点\r\n        //cur代表要删除的节点\r\n        Node prev = this.head;\r\n        Node cur = prev.next;\r\n        while (cur != null) {\r\n            if (cur.data == key) {\r\n                //删除元素\r\n                prev.next = cur.next;\r\n                cur = cur.next;\r\n            } else {\r\n                prev = cur;\r\n                cur = cur.next;\r\n            }\r\n        }\r\n        if (head.data == key) {\r\n            this.head = this.head.next;\r\n        }\r\n    }\r\n\r\n    //得到单链表的长度\r\n    public int size() {\r\n        Node cur = this.head;\r\n        int count = 0;\r\n        while (cur != null) {\r\n            count++;\r\n            cur = cur.next;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    //打印单链表\r\n    public void display() {\r\n        Node cur = this.head;\r\n        while (cur != null) {\r\n            System.out.print(cur.data + \" \");\r\n            cur = cur.next;\r\n        }\r\n        System.out.println();\r\n    }\r\n\r\n\r\n    //释放内存\r\n    public void clear() {\r\n        this.head = null;\r\n    }\r\n————————————————\r\n', 1);
INSERT INTO `article` VALUES (7, '数据库基本操作', '连接：	net statt mysql\r\n打开数据库：mysql  -uroot\r\n\r\nmysql的数据库的基本操作(每一句以“；”结尾，不区分大小写)\r\n一.库的操作\r\n1.查看MySQL数据库：show databases;\r\n2.如何创建库：Create database 库名；（名称以英文或符号起始，不允许数字起始）\r\n（库的名称，表的名称，字段名称都不能使用关键字，比如：Create,database,如非要使用，使用反引号括     	起来，如：Create database `database`;)\r\n3.如何删除数据库：drop database `databdse`;\r\n4.选择使用数据库：use 库名；（因为mysql有多个库，因此在操作前选择数据库）\r\n5.显示当前使用的数据库：select database();\r\n二.mysql数据库中的数据类型\r\n数字类型：BIT[M]——比特位，INT——整形，DECIMAL(M,D)——浮点型\r\n字符类型：VARCHAR(SIZE),TXET(SIZE)\r\nVARCHAR和CHAR的区别：空间是否长度固定。\r\n日期类型：DATETIME/TIMESTAMP\r\n三.mysql数据库中表的操作\r\n显示库中所有表：show tables；\r\n创建表：create table tb_name(field1 type,field2 type,..... ) ->\r\ncreate table if not exists tb_student(id int ,\r\nname varchar(3),\r\nage int,\r\nyuwen decimal(4,2),\r\nshuxue decimal(4,2),\r\nbirth datetime);\r\n查看表结构：desc 表名;   -->desc tb_student;\r\n删除表：drop table 表名； -->drop tb_student;\r\n', 1);
INSERT INTO `article` VALUES (8, '数据库表中的数据增删改查基础', '添加数据：insert\r\n指定列插入：\r\ninsert  into 数据表名 （field1,field2,...) values(val1,val2,...);   值的顺序必须与字段顺序一致\r\ninsert into tb_student(id,name,yuwen,birth) values(1,\"张三\",77.7,\"2018-02-03 12:13:21\");\r\n全局插入：\r\ninsert into 数据表名 values(......);   给与的数据必须所有列的数据必须跟表中的字段顺序相同\r\ninsert into tb_student values(1,\"李四\",18,77.7,88.8,now());\r\n多行插入：\r\ninsert into 数据表名 values(......),(......);\r\ninsert into tb_student values(3,\"王五\", 19 , 58.5 , 59.9 , now()),(4,\"刘六\", 17 , 98.5 , 89.9 , now());\r\n\r\n查看数据：select\r\n全列查询：select * from 数据表名； -->select * from tb_student;\r\n\r\n指定列查询：select fieids1,fields2...form 数据表名； -->select name,yuwen from tb_student; \r\n\r\n排序查询：select * from 数据表名 order by 字段名 [asc]/desc;    默认asc升序排列，desc为降序排列 -->select * from tb_student order by yuwen asc;\r\n    多列排序：在第一列相同的情况下针对第二列进行排序：-->select * from 数据表名 order by 字段名 asc,字段名 desc;\r\n\r\n分页查询：通常搭配排序使用\r\n    在所有数据中只要前n条：select * from 数据表名 limit 数字； -->select * from tb_student limit 3; limit 3表示前3条\r\n    从第s条开始查询前n条： select * from 数据表名 limit n offset s；-->select * from tb_student limit 3 offset 3;offset表示偏移量，默认offset 0\r\n列如：每页显示10条，第5页数据的请求：select * from tb_student order by yuwen limit 10 offset 10*5;\r\n\r\n查询字段为表达式：-->select name,yuwen+shuxue from tb_student;\r\n字段为别名的使用： -->select name,yuwen+shuxue  [as] total from tb_student;\r\n       \r\n数据去重：select distinct age ,name from tb_student; 根据某一字段进行去重，查看去重后这个字段的数据   \r\n\r\n\r\n\r\n修改数据： update\r\nupdate 数据表名 set field=val1,field2=val2 where condition; 尤其注意不要条件忘了，否则针对针对整张表中的数据产生效果\r\nupdate tb_student set age=20,shuxue=96 where id=2;\r\n删除数据：delete\r\ndelete from 数据表名 where condition;尤其注意不要把条件忘了，否则针对整张表所有数据产生效果\r\ndelete from tb_student where name=\"张三\";', 1);
INSERT INTO `article` VALUES (9, '哈希表', '1.概念：\r\n查找一个元素时，必须要经过关键\r\n码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(logN)，理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函\r\n数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快\r\n找到该元素。\r\n插入元素和搜索元素时间复杂度都为O(1)，该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash\r\nTable)(或者称散列表)\r\n\r\n2.冲突\r\n对于两个数据元素的关键字 和 (i != j)，有 != ，但有：Hash( ) == Hash( )，即：不同关键字通过相同哈\r\n希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。\r\n避免冲突（重点）：\r\n由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一\r\n个问题，冲突的发生是必然的，但我们能做的应该是尽量的降低冲突率。\r\n\r\n设计哈希函数：\r\n1. 直接定制法--(常用)：\r\n取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B\r\n2. 除留余数法--(常用)：\r\n地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：\r\nHash(key) = key% p(p<=m),将关键码转换成哈希地址\r\n负载因子：\r\n负载因子 = 当前元素存放的个数/数组的长度  哈希表中的负载因子一般为0.75 \r\n已知哈希表中已有的关键字个数是不断增加的，那我们能调整的就只有哈希表中的数组的大小。\r\n\r\n解决冲突(重点)：\r\n解决冲突的方法有两种，闭散列和开散列/哈希桶。\r\n闭散列又称开发地址法：当哈希表发生冲突时，如果哈希表未满，我们可以通过线性探测法(相同的哈希函数)，找到冲突位置的下一个\"空位置\"中去。\r\n开散列又称链地址法（背）：首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子\r\n集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中（jdk1.7用头插法，jdk1.8用尾插法,原因是因为在多线程情况下，容易编程死循环）。\r\n\r\n3.面试题\r\n\r\nequal与hashcode的区别 - 托马斯骨头收集 - 博客园 (cnblogs.com)\r\nHashMap面试题 - 托马斯骨头收集 - 博客园 (cnblogs.com)', 1);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `userId` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`userId`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'dwt', '123456');
INSERT INTO `user` VALUES (2, 'cxz', '123456');
INSERT INTO `user` VALUES (3, 'dwt1', '123456');

SET FOREIGN_KEY_CHECKS = 1;
